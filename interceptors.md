# Interceptors
<img src="/images/RestJS-framework-interceptors.jpg"/>

Interceptors are like [pipes](pipes.md) with some differences.
If you've passed [pipes](pipes.md) session, you should know that we use pipes for transformation and validation . 
Pipes control only the in-coming message, not out-coming message.

Sometimes you need to transform the result message that is generated by the controller.

For example, you can create an interceptor named `PageInterceptor` to render the result of controller message to a simple HTML page .

# Example
Create a file with this path : `./src/interceptors/PageInterceptor.tsx`
```
import React, {ReactElement} from "react";
import ReactDOMServer from "react-dom/server";

export interface PagePropsInterface {
    title : ReactElement | string;
    content : ReactElement | string;
    user? : any;
}

function PageLayout(props : PagePropsInterface) : React.ReactElement{
    return(
        <html>
            <head>
                <title>{props.title}</title>
            </head>
            <body>
                <h2 style={{color : "red", fontSize : 30, fontWeight : "bold"}}>
                    {props.title}
                </h2>
                <span style={{margin : 20, fontSize : 20}}>
                    {props.content}
                </span>
                <br/>
                <span style={{margin : 20}}>
                    You've logged in as :
                    <span style={{color:"blue"}}>
                         {props.user.name}
                    </span>
                </span>
            </body>
        </html>
    )
}

export default class PageInterceptor {
    in(req,res){
        req.user = {id : 1, name : "Edward Norton"};
        return true;
    }

    out(message : PagePropsInterface){
        return(
            ReactDOMServer.renderToStaticMarkup(
                <PageLayout {...message}/>
            )
        );
    }
}
```
There is a function named `PageLayout`,it's a simple functional react component, that we use it to create our layout of the pages.
We have also a class called `PageInterceptor`, this class actually has tow methods to control in-coming and out-coming data.

> Notice : `in` and `out` methods have to return a true value to let the request, or the response to pass away. If it returns a false value the request will be stoped


`in` method will be executed before the `controller`, in this example, it modifies the `req` object,it adds an object named `user` into it.

In this example, we're adding a user to the request, literally(in-line), but in the real-world, you can read the user from the database or somewhere else and then add it into the `req` object.


`out` method will be executed exactly after the controller's method executed successfully without any error (HttpException). It uses a package called `react-dom/server` to render react elements to a plain text.

For the next step you have to apply the interceptor on the application's router :
**./src/main.tsx**
```
import React from 'react';
import {Application, Router, Get} from '@restjs/core';
import PageController from "./controllers/PageController";
import PageInterceptor from "./interceptors/PageInterceptor";

const app : React.ReactElement = (
    <Application
        onListen={()=>{
            console.log('Rest-JS app is running on : http://localhost:3000');
        }}
    >
        <Router path="/" controller={PageController} interceptors={[PageInterceptor]}>
            <Get path="/" handle="index"/>
            <Get path="/blog/:slug" handle="blog"/>
            <Get path="/get-started" handle="getStarted"/>
        </Router>
    </Application>
)

Application.run(app);
```
In the second route with path `/blog/:slug` we've used a dynamic parameter that will be available on `req.params.slug`. As you maybe know RestJS uses `express-js` to implement the routing system, you can read more about routing [HERE](https://expressjs.com/en/guide/routing.html).

Finally, create some methods in a controller to provide some data for the page interceptor's out method.


**./src/controllers/PageController.tsx**
```
import React from "react";
import {PagePropsInterface} from "../interceptors/PageInterceptor";

export default class PageController{

    index(req, res) : PagePropsInterface{
        return({
            title : "Home Page",
            content : "Welcome to RestJS framework, This is our home page...",
            user : req.user,
        })
    }

    blog(req, res) : PagePropsInterface{
        return({
            title : "Blog slug : " + req.params.slug,
            content : "This route is dynamic, this means you can use routes like /blog/rest-js , /blog/react and etc.",
            user : req.user,
        })
    }

    getStarted(req, res) : PagePropsInterface{
        return({
            title : "Get started!",
            content : (
              <span>
                  Please visit our official website to get started :
                  <a href="https://restjs.github.io">RestJS</a>
              </span>
            ),
            user : req.user,
        })
    }
}
```

Run your application with `npm run dev` and open these routes to see the result and realize how it works:

http://localhost:3000

http://localhost:3000/get-started

http://localhost:3000/blog/Rest-JS

http://localhost:3000/blog/a-beautiful-day


# Sharing
Every `Router` shares its interceptors to all children such as `Router`, `Get`, `Post` and etc.
In the following code the main router with path "/" will share its interceptors to the `Router` with path "/api/user", no matter how many times the routers are nested, it always shares the interceptor instances with its children.
```
<Router path="/" controller={MainController} interceptors={[ExampleInterceptor]}>
    <Get path="/search" handle="search"/>
    <Router path="/api" controller={UserController}>
        <Get path="/users" handle="users"/>
    </Router>
</Router>
```

## Ignore parent interceptors
Sometimes you don't need to shared interceptor instances in a child router component.
Then you can easily avoid the sharing between the nested routers by adding a prop named `ignoreParentInterceptors` into the router component.
```
<Router path="/" controller={MainController} interceptors={[ExampleInterceptor]}>
    <Get path="/search" handle="search"/>
    <Router path="/api" controller={UserController} ignoreParentInterceptors/>
        <Get path="/users" handle="users"/>
    </Router>
</Router>
```
As you can see the parent router won't share its interceptors to "/api" router.
